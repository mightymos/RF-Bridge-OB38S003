/*
 *
 *  Ported on: 02.16.2023
 *      Author: Jonathan Armstrong
 */

#include <8052.h>

 
#include "hal.h"
#include "ob38s003.h"
#include "sonoffr22_pins.h"



inline void buzzer_on(void)
{
    BUZZER = 1;
}

inline void buzzer_off(void)
{
    BUZZER = 0;
}

inline bool rdata_level(void)
{
    return RDATA;
}

// setter prototypes
inline void led_on(void)
{
    LED = 1;
}

inline void led_off(void)
{
    LED = 0;
}

inline void led_toggle(void)
{
    LED = !LED;
}


inline void radio_receiver_off(void)
{
    RF_ENABLE = 1;
}


inline void radio_receiver_on(void)
{
    RF_ENABLE = 0;
}

inline bool get_radio_wake(void)
{
    return RF_ENABLE;
}

inline void reset_pin_on(void)
{
    RESET_PIN = 1;
}

inline void reset_pin_off(void)
{
    RESET_PIN = 0;
}

inline void reset_pin_toggle(void)
{
    RESET_PIN = !RESET_PIN;
}

inline void tdata_on(void)
{
    TDATA = 1;
}


inline void tdata_off(void)
{
    TDATA = 0;
}


inline void uart_tx_pin_off(void)
{
    UART_TX_PIN = 0;
}


inline void uart_tx_pin_on(void)
{
    UART_TX_PIN = 1;
}

inline void uart_tx_pin_toggle(void)
{
    UART_TX_PIN = !UART_TX_PIN;
}

void set_clock_1t_mode(void)
{
    // default is 2T mode
    // ITS = 000 or 1T mode
    CKCON = 0x00;
}

void set_clock_6t_mode(void)
{
    // ITS = 101 or 6T mode
    CKCON = 0x50;
}

// pg. 44 - once the watchdog is started it cannot be stopped
void enable_watchdog(void)
{
    // changes WDTC from read only
    TAKEY = 0x55;
    TAKEY = 0xAA;
    TAKEY = 0x5A;
    
    // sets WDTE bit
    WDTC |= 0x20;
}

void refresh_watchdog(void)
{
    // pg. 46 - Clear WDT timer to 0.
    WDTK = 0x55;
}

void init_port_pins(void)
{
    // buzzer push pull
    P0M1 &= ~0x01;
    P0M0 |=  0x01;
    
    // uart tx push pull
    //P1M1 &= ~0x01;
    //P1M0 |=  0x01;
    
    // radio incoming input only
    //P1M1 |=  0x40;
    //P1M1 &= ~0x40;
    
    // DEBUG: try enabling pullup on data pin
    //P1_6 = 1;
    
    // rf sleep/wake push pull
    //P1M1 &= ~0x10;
    //P1M1 |=  0x10;
    
    // led push pull
    P3M1 &= ~0x01;
    P3M0 |=  0x01;
    
}


void init_uart(void)
{
    // BRGS = 1 so uart baud rate generator uses SREL (instead of timer 1)
    AUX |= 0x80;
    
    // mode 1, no parity bit SM0 = 0 and SM2 = 0 by default
    SM1 = 1;
    
	// uart reception enabled
    REN = 1;
    
    // see formula below with SMOD = 1
    PCON |= SMOD;
    
    // SRELPS0 = 1;
    PFCON |= 0x10;
    
    // pg. 43, sec. 8.4.1.2
    // baud rate = (2^SMOD x Fosc) / ((32 or 64) * (2^10 - SREL))
    // SRELPS[1:0] = 00 divisor is 64, 01 divisor is 32
    // (2^1 * 16000000)/(32*(2^10 - 920)) = 9615
    // FIXME: consider computing with macro dependent on clock frequency
    //SRELH = 0x03;
    //SRELL = 0x98;
    
    // 19200
    SRELH = 0x03;
    SRELL = 0xcc;
}

void init_serial_interrupt(void)
{
    // enable serial interrupt
    ES = 1;
}

void init_capture_interrupt(void)
{
    //pg. 33 Compare/Capture interrupt share T2 interrupt vector.
    // compare/capture 1 interrupt control bit
    CCCON |= 0x20;
}

void disable_capture_interrupt(void)
{
    CCCON &= ~0x20;
}

void enable_capture_interrupt(void)
{
    CCCON |= 0x20;
}

void init_timer0(void)
{
    // 16-bit mode
    TMOD |= T0_M0;
    
    // FIXME: T0PS 0x10 prescaler fosc
    PFCON |= 0x01;
    
    // one millisecond to overflow
    TH0 = 0xc1;
    TL0 = 0x7f;
    
    
    // ten microseconds to overflow
    //TH0 = 0xff;
    //TL0 = 0x5f;
    
    // enable timer0 overflow interrupt
    ET0 = true;
    
    // enable timer0
    TR0 = true;
}

void init_timer1(void)
{
    // 16-bit mode
    TMOD |= T1_M0;
    
    // T1PS prescaler fosc
    PFCON |= 0x08;
    
    // ten microseconds to overflow
    //TH1 = 0xff;
    //TL1 = 0x5f;
    
    // enable timer1 overflow interrupt
    ET1 = true;
    
    // enable timer1
    TR1 = true;
}

//================================================================================
//================================================================================
void init_timer2_capture(void)
{
    // capture on both rising and falling edge at pin CC1
    //(i.e., P1.6 or RDATA which is input from D0 of radio)
    CCEN  = 0x60;
    
    // time 2 input frequency from prescaler
    // timer 2 mode 0 auto reload (generated by a timer 2 overflow)
    // timer 2 is clocked with 1/4 (0x51) or 1/24 (0xD1) of the oscillator frequency (prescaler select bit)
    // (e.g., 0.25 microseconds per count)
    T2CON = 0xD1;
}

void enable_global_interrupts(void)
{
    EA = 1;
}

void disable_global_interrupts(void)
{
    EA = 0;
}

bool global_interrupts_are_enabled(void)
{
    return EA;
}

void enable_timer0_interrupt(void)
{
    ET0 = 1;
}

void disable_timer0_interrupt(void)
{
    ET0 = 0;
}

void enable_timer1_interrupt(void)
{
    ET1 = 1;
}

void disable_timer1_interrupt(void)
{
    ET1 = 0;
}

void load_timer0(unsigned int value)
{
    TH0 = (value >> 8) & 0xff;
    TL0 = value & 0xff;
}

void load_timer1(unsigned int value)
{
    TH1 = (value >> 8) & 0xff;
    TL1 = value & 0xff;
}

unsigned char get_timer2_low(void)
{
    return CCL1;
}

unsigned char get_timer2_high(void)
{
    return CCH1;
}

void clear_ccp1_flag(void)
{
    CCCON &= ~0x02;
}

unsigned char get_stack_pointer(void)
{
    return SP;
}